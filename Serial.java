//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by FernFlower decompiler)
//

/**IMPORTANT: REMEMBER TO MOVE THE CLASS FILE (GENERATED BY COMPILING THIS JAVA FILE) TO THE SPECIFIED PACKAGE**/
package cl.transbank.pos.utils;

import cl.transbank.pos.exceptions.common.TransbankException;
import cl.transbank.pos.responses.common.IntermediateResponse;
import com.fazecast.jSerialComm.SerialPort;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Timer;
import java.util.TimerTask;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

public class Serial {
    private static final Logger log = LogManager.getLogger(Serial.class);
    protected static final byte ACK = 6;
    public static final int DEFAULT_TIMEOUT = 150000;
    public static final int DEFAULT_BAUDRATE = 115200;
    private static final char STX = '\u0002';
    private static final char ETX = '\u0003';
    private int timeout = 150000;
    protected String currentResponse;
    protected SerialPort port;
    protected List<String> saleDetailResponse;
    private OnIntermediateMessageReceivedListener onIntermediateMessageReceivedListener;

    public Serial() {
    }

    public void setOnIntermediateMessageReceivedListener(OnIntermediateMessageReceivedListener listener) {
        this.onIntermediateMessageReceivedListener = listener;
    }

    private void setCurrentResponse(String response) {
        this.currentResponse = response;
        if (this.currentResponse.length() >= 1 && this.getFunctionCode().equals("0900") && this.onIntermediateMessageReceivedListener != null) {
            this.onIntermediateMessageReceivedListener.onReceived(new IntermediateResponse(this.currentResponse));
        }

    }

    public List<String> listPorts() {
        List<String> serialPorts = new ArrayList();
        SerialPort[] ports = SerialPort.getCommPorts();
        SerialPort[] var3 = ports;
        int var4 = ports.length;

        for(int var5 = 0; var5 < var4; ++var5) {
            SerialPort serialPort = var3[var5];
            serialPorts.add(serialPort.getSystemPortName());
        }

        return serialPorts;
    }

    public boolean openPort(String portName) {
        log.debug(String.format("Opening port %s", portName));
        return this.openPort(portName, 115200);
    }

    public boolean openPort(String portName, int baudRate) {
        this.port = SerialPort.getCommPort(portName);
        this.port.setBaudRate(baudRate);
        return this.port.openPort();
    }

    public boolean closePort() {
        return this.port.closePort();
    }

    protected void checkCanWrite() throws TransbankException {
        if (this.port == null || !this.port.isOpen()) {
            throw new TransbankException("Can't write to port, the port is null or not open");
        }
    }

    /** First modification:
     * The serialCommand can now be executed with 3 input arguments:
     * @param payload -> is the "regular" content of the command
     * @param _header -> represents the header or starting characters of that message
     * @param _footer -> represents the footer or ending characters of that message
     * @return -> it returns the complete command (i.e., header followed by the payload followed by the footer), with the Longitudinal Redundancy Check (LRC) attached to it
     *
     * IMPORTANT: if no header and/or footer values are to be assigned (i.e., if it should take the default values for any/both of those variables), they should
     * be specified as "null" when calling the method. For example, if we wanted to call the method with a certain payload and a certain header too
     * but using the default footer, which is the character ETX, we should call it like createCommand(<payload>,<_header>,null)
     * (where obviously <payload> and <_header> stand for our payload and header values respectively)
     */
    protected String createCommand(String payload, String _header, String _footer) {
        // Default header -> STX (\u0002)
        String header = new String("\u0002");
        // Default footer -> ETX (\u0003)
        String footer = new String("\u0003");
        // Let's see if the user has modified the default header and/or footer...
        header = (_header!=null)?_header:header;
        footer = (_footer!=null)?_footer:footer;
        String fullCommand = header + payload + footer;
        return fullCommand + this.lrc(fullCommand);
    }

    private char lrc(String command) {
        char lrc = 0;

        for(int i = 1; i < command.length(); ++i) {
            lrc ^= command.charAt(i);
        }

        return lrc;
    }

    /** Experimental approach:
     * In order to ensure a proper and correct error-detection, we suggest using a CRC instead of an LRC.
     * As the command variable will be a string type object formed by different char units, an 8-bit CRC is the most
     * reasonable approach. In fact char type variables are 16 bits in size (each of them); usually only 8 of them are
     * used, but in total there are 16 bits just for being able to store characters from every language. The divider
     * polynomial can be sent as a parameter, but the default value we are going to use is x^8+x^2+x+1, which is the
     * widely known CRC-8-ATM (HEC). After the execution, the last n bits of the remainder of the calculations will be
     * returned, where n matches the polynomial degree; this bits will represent the computed CRC, which has to be
     * checked in order to ensure that the transmission process is free of errors.
     */
    private static char ComputingCRC(String _message, String _dividerPolynomial) {   // Be careful with the difference between returning a char or a String!!!
        //The divider polynomial could be introduced as a parameter when calling the method
        String dividerPolynomial = (_dividerPolynomial!="default")?_dividerPolynomial:"100000111";  // By default we will use the 8-bit CRC-8-ATM polynomial, which is P(x)=x^8+x^2+x+1
        // Check the dividerPolynomial degree
        int degree = dividerPolynomial.length()-1;
        // Convert the message into a "binary string"
        String message = StringToBinary(_message);
        // We need to get the message right-padded with as many zeros as the divider polynomial degree (if they are not equal in length)
        for (int z=0; z<degree; z++) {
            message += "0";
        }
        while (message.length()!=dividerPolynomial.length()) {
            if (message.length()>dividerPolynomial.length()) {
                dividerPolynomial += "0";
            }
            else if (message.length()<dividerPolynomial.length()) {
                message += "0";
            }
        }
        // Number of zeros before the first remaining 1 in the message
        int previousZeroCount = 0;
        // While the dividerPolynomial hasn't reached the right-hand end of the message (i.e., if the message does not contain any 1s on the first k bits, where k is message.length()-degree)
        while(message.substring(0,message.length()-degree).contains("1")) {
            // The zeroCount variable will come in handy to know how many positions we have to shift the dividerPolynomial until it is aligned with the first non-zero bit of message (i.e., it stores the position of the first non-zero bit in message)
            int zeroCount = 0;
            // Search for the first non-zero bit in message
            while (zeroCount<message.length()) {
                if (message.charAt(zeroCount)=='1') {
                    break;
                }
                else {
                    zeroCount++;
                }
            }
            // By default, in each step we will have to shift the dividerPolynomial at least 1 bit to the right (i.e., it has appeared at least 1 bit on the left of the first non-zero bit of message)
            if ((zeroCount==0)&&(message.charAt(0)!='1')) {
                zeroCount++;
            }
            // Shift the divider polynomial the number of times indicated in the shifting variable
            for (int i=0; i<zeroCount-previousZeroCount; i++) {
                dividerPolynomial = '0' + dividerPolynomial.substring(0,dividerPolynomial.length()-1);
            }
            // We XOR (actually, this is a "String XOR") the message with the dividerPolynomial (and we store the result in message)
            char[] messageCharArray = message.toCharArray();    // Since it's easier, we'll work with char arrays instead of Strings
            char[] dividerPolynomialCharArray = dividerPolynomial.toCharArray();
            for (int i=0; i<messageCharArray.length; i++) { // Loop through the entire char array
                // Perform the XORing
                if (messageCharArray[i]==dividerPolynomialCharArray[i]) {
                    // If 2 characters at the same position in message and dividerPolynomial are equal (either if they are both "1" or "0") the result will be "0", and it will be stored in message in that precise position
                    messageCharArray[i] = '0';
                }
                else {
                    // If they are different, the stored result will be "1"
                    messageCharArray[i] = '1';
                }
            }
            // Convert the char arrays back into Strings
            message = new String(messageCharArray);
            dividerPolynomial = new String(dividerPolynomialCharArray);
            // Save the previous number of zeros before the first 1 in message
            previousZeroCount = zeroCount;
        }
        //return BinaryStringToCharValue(message.substring(message.length()-degree,message.length()-1)+'0'); // We only return the last n bits on the reminder (where n is the degree of the dividerPolynomial)
        return BinaryStringToCharValue(message.substring(message.length()-degree,message.length()-1)+'0');
    }

    /** Experimental approach:
     * As mentioned in the description of the ComputingCRC method, the computed CRC has to be checked in order to detect
     * any error in the transmission process; this method has been created for that purpose. It will go through the
     * same steps shown in the previous method (i.e., XOR-ing and shifting) until the same condition is reached (i.e.,
     * the first n bits of the message are 0s). Then it will look at the remainder of those calculations, and if it
     * doesn't contain 1s (i.e., if the remainder is equal to 0), it means that the CRC checking process has not
     * detected any error and it will return true. Otherwise (i.e., if the remainder is not equal to 0 because it
     * contains at least one 1), it will return false, since the CRC checking process has found transmission errors.
     */
    public static boolean CheckingCRC(String _receivedMessage, String _dividerPolynomial, char _CRC) {
        // We'll work with char type CRCs because it can come in handy later
        String tempCRC = "";
        tempCRC += _CRC;
        String CRC = StringToBinary(tempCRC);
        // Concat the computed CRC to the received message
        String message = StringToBinary(_receivedMessage)+CRC;
        /* From now on, the code will be almost identical to the ComputingCRC function */
        // Initializing the dividerPolynomial
        String dividerPolynomial = (_dividerPolynomial!="default")?_dividerPolynomial:"100000111";
        // Check the dividerPolynomial degree
        int degree = dividerPolynomial.length()-1;
        // Zero-padding applied
        while (message.length()!=dividerPolynomial.length()) {
            if (message.length()>dividerPolynomial.length()) {
                dividerPolynomial += "0";
            }
            else if (message.length()<dividerPolynomial.length()) {
                message += "0";
            }
        }
        // Number of zeros before the first remaining 1 in the message
        int previousZeroCount = 0;
        // While the dividerPolynomial hasn't reached the right-hand end of the message (i.e., if the message does not contain any 1s on the first k bits, where k is message.length()-degree)
        while(message.substring(0,message.length()-degree).contains("1")) {
            // The zeroCount variable will come in handy to know how many positions we have to shift the dividerPolynomial until it is aligned with the first non-zero bit of message (i.e., it stores the position of the first non-zero bit in message)
            int zeroCount = 0;
            // Search for the first non-zero bit in message
            while (zeroCount<message.length()) {
                if (message.charAt(zeroCount)=='1') {
                    break;
                }
                else {
                    zeroCount++;
                }
            }
            // By default, in each step we will have to shift the dividerPolynomial at least 1 bit to the right (i.e., it has appeared at least 1 bit on the left of the first non-zero bit of message)
            if ((zeroCount==0)&&(message.charAt(0)!='1')) {
                zeroCount++;
            }
            // Shift the divider polynomial the number of times indicated in the shifting variable
            for (int i=0; i<zeroCount-previousZeroCount; i++) {
                dividerPolynomial = '0' + dividerPolynomial.substring(0,dividerPolynomial.length()-1);
            }
            // We XOR (actually, this is a "String XOR") the message with the dividerPolynomial (and we store the result in message)
            char[] messageCharArray = message.toCharArray();    // Since it's easier, we'll work with char arrays instead of Strings
            char[] dividerPolynomialCharArray = dividerPolynomial.toCharArray();
            for (int i=0; i<messageCharArray.length; i++) { // Loop through the entire char array
                // Perform the XORing
                if (messageCharArray[i]==dividerPolynomialCharArray[i]) {
                    // If 2 characters at the same position in message and dividerPolynomial are equal (either if they are both "1" or "0") the result will be "0", and it will be stored in message in that precise position
                    messageCharArray[i] = '0';
                }
                else {
                    // If they are different, the stored result will be "1"
                    messageCharArray[i] = '1';
                }
            }
            // Convert the char arrays back into Strings
            message = new String(messageCharArray);
            dividerPolynomial = new String(dividerPolynomialCharArray);
            previousZeroCount = zeroCount;
        }
        // If the remainder contains any 1, it means that the CRC checking process detected an error (in that case the "contains" instruction will return true, and we will invert it to return false as the result of the CRC checking process)
        // Else, if the remainder contains only 0s, it means that the CRC checking process has succeeded (in that case the "contains" instruction will return false, and we will invert it to return true as the result of the CRC checking process)
        return !(message.substring(message.length()-degree,message.length()-1).contains("1"));
    }

    /** Handy methods*/
    private static String StringToBinary(String msg) {
        StringBuilder sbBinary = new StringBuilder();
        char[] commandCharArray = msg.toCharArray();
        for (char c : commandCharArray) {
            sbBinary.append(String.format("%8s", Integer.toBinaryString(c)).replaceAll(" ", "0"));  // Char to integer cast and zero-padding
        }
        return sbBinary.toString();
    }
    private static char BinaryStringToCharValue(String binStr) {
        // Result of the conversion (decimal number)
        int result = 0;
        // The multiplier will be updated through each iteration (2,4,8,16...)
        int multiplier = 1;
        // We "mirror" the binStr so that it starts with the bit corresponding to the 1 position and it ends with the bit corresponding to the 2^(n-1) position (where n is the length of the bitStr)
        StringBuilder sbBinStr = new StringBuilder();
        sbBinStr.append(binStr);
        sbBinStr.reverse();
        String newBinStr = sbBinStr.toString();
        // We loop through the entire "binary String"
        for (int i=0; i<newBinStr.length(); i++) {
            // If the bit in the position we are currently going over is 1
            result += multiplier*Character.getNumericValue(newBinStr.charAt(i));
            // We update the multiplier variable
            multiplier *= 2;
        }
        // We return the char value of the conversion we've just realized
        return (char) result;
    }

    /** Second modification:
     * There are 3 different write method options which have been changed, so they match up the changes applied to the createCommand method.
     * New _header and _footer input arguments have been introduced for that purpose.
     */
    public void write(String payload, String _header, String _footer) throws TransbankException {
        this.write(payload, _header, _footer, false, false, false);
    }

    public void write(String payload, String _header, String _footer, boolean intermediateMessages) throws TransbankException {
        this.write(payload, _header, _footer, intermediateMessages, false, false);
    }

    public void write(String payload, String header, String footer, boolean intermediateMessages, boolean saleDetail, boolean printOnPOS) throws TransbankException {
        this.currentResponse = "";
        this.checkCanWrite();
        /** Possible problem with hex conversion during the message creation procedure!
         * In principle, it should work fine with the default header and footer values, as they are string type objects
         * containing the values "\u0002" and "\u0003" respectively, and "translating" them to hex values gives us
         * the correct 2nd and 3rd characters of the ASCII alphabet, which are the STX and ETX characters. Keep an eye
         * on it, because adding a custom header and/or footer implies taking in mind that those values are going to be
         * converted to hex, so we need to add values that, when converted, represent something logic in hex.
         */
        String command = this.createCommand(payload, header, footer);
        byte[] hexCommand = command.getBytes();
        log.debug(String.format("Request [Hex]: %s", this.toHexString(hexCommand)));
        log.debug(String.format("Request [ASCII]: %s", command));
        this.port.writeBytes(hexCommand, (long)hexCommand.length);
        if (!this.checkAck()) {
            throw new TransbankException("NACK received, check the message sent to the POS");
        } else {
            log.debug("Read ACK Ok");
            String authorizationCode;
            if (intermediateMessages) {
                this.readResponse();

                for(authorizationCode = this.getResponseCode(); this.checkIntermediateMessage(authorizationCode); authorizationCode = this.getResponseCode()) {
                    this.readResponse();
                }

            } else if (!saleDetail) {
                this.readResponse();
            } else {
                this.saleDetailResponse = new ArrayList();
                authorizationCode = "Start";

                while(!authorizationCode.trim().isEmpty() && !printOnPOS) {
                    this.readResponse();

                    try {
                        authorizationCode = this.getAuthorizationCode();
                        if (!authorizationCode.trim().isEmpty()) {
                            this.saleDetailResponse.add(this.currentResponse);
                        }
                    } catch (IndexOutOfBoundsException var9) {
                        authorizationCode = "";
                    }
                }

            }
        }
    }

    private void readResponse() throws TransbankException {
        this.waitResponse();
        int bytesAvailable = this.port.bytesAvailable();
        byte[] response = new byte[bytesAvailable];
        this.port.readBytes(response, (long)bytesAvailable);
        if (response[response.length - 2] != 3) {
            this.waitResponse();
            int fullResponseLength = bytesAvailable;
            bytesAvailable = this.port.bytesAvailable();
            fullResponseLength += bytesAvailable;
            byte[] fullResponse = Arrays.copyOf(response, fullResponseLength);
            this.port.readBytes(fullResponse, (long)bytesAvailable, (long)response.length);
            response = fullResponse;
        }

        this.setCurrentResponse(new String(response, StandardCharsets.UTF_8));
        log.debug(String.format("Response [Hex]: %s", this.toHexString(response)));
        log.debug(String.format("Response [ASCII]: %s", this.currentResponse));
        this.writeAck();
    }

    protected boolean checkAck() throws TransbankException {
        byte[] response = new byte[1];
        this.waitResponse();
        this.port.readBytes(response, (long)this.port.bytesAvailable());
        log.debug(String.format("Checking ACK [Hex]: %02X", response[0]));
        return response[0] == 6;
    }

    private void waitResponse() throws TransbankException {
        final boolean[] isTimeoutCompleted = new boolean[]{false};
        Timer timer = new Timer();
        TimerTask timerTask = new TimerTask() {
            public void run() {
                isTimeoutCompleted[0] = true;
            }
        };
        timer.schedule(timerTask, (long)this.timeout);

        while(this.port.bytesAvailable() <= 0 && !isTimeoutCompleted[0]) {
        }

        if (isTimeoutCompleted[0]) {
            timer.cancel();
            throw new TransbankException("Read operation Timeout");
        } else {
            timer.cancel();
        }
    }

    private void writeAck() {
        byte[] ack = new byte[]{6};
        log.debug(String.format("Send ACK [Hex]: %02X", ack[0]));
        this.port.writeBytes(ack, (long)ack.length);
    }

    protected String toHexString(byte[] data) {
        StringBuilder sb = new StringBuilder();

        for(int i = 0; i < data.length; ++i) {
            sb.append(String.format("%02X%s", data[i], i < data.length - 1 ? "-" : ""));
        }

        return sb.toString();
    }

    private String getResponseCode() {
        return this.currentResponse.substring(1, this.currentResponse.length() - 2).split("\\|")[1];
    }

    private String getFunctionCode() {
        return this.currentResponse.substring(1, this.currentResponse.length() - 2).split("\\|")[0];
    }

    private String getAuthorizationCode() {
        return this.currentResponse.substring(1, this.currentResponse.length() - 2).split("\\|")[5];
    }

    private boolean checkIntermediateMessage(String responseCode) {
        List<String> intermediateMsg = new ArrayList(Arrays.asList("78", "79", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89"));
        return intermediateMsg.contains(responseCode);
    }

    public int getTimeout() {
        return this.timeout;
    }

    public void setTimeout(int timeout) {
        this.timeout = timeout;
    }

    public interface OnIntermediateMessageReceivedListener {
        void onReceived(IntermediateResponse var1);
    }
}
